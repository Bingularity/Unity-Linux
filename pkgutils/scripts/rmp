#!/bin/sh
#
#  rmp
#
#  Copyright (C) 2009 Steven J Stover <stumpy@unity-linux.org>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#
# # # # # # # # # # # # # # # # #
#  Remove packages using smart  #
#  from a listfile              #
# # # # # # # # # # # # # # # # #

# name of this script
myname=$(basename $0)
#
# name of the .mo file for translations
moname="pkgutils"
#
# change tmp if bldpkg uses another tmp dir
tmp="/tmp"
# change rmpkg if bldpkg changes the extension of its listfiles
rmpkg="rmpkg"
#

# This function is for giving the script i18n support.
__ () {
	local gettextopts="-d $moname -e --"
        local TEXT=`gettext $gettextopts "$1"`		# Unfortunately `` and $() remove any trailing newlines
							# so, if one is present, it must be restored.
							# Please, note that if more newlines are present
							# they will be reduced to one.
	[ "$(echo $1|grep "\\n$")" ] && TEXT="$TEXT\n"	# If $1 ends with \n append \n to TEXT
	[[ $1 = *$'\n' ]] && TEXT="$TEXT\n"		# If $1 ends with newline append \n to TEXT
	shift
	printf -- "$TEXT" "$@"
}

showhelp () {
	cat <<-EOF >&2
$(__ "Usage: %s [OPTION]... [FILE]...
Remove packages using smart from listfiles, like the
*.<env>.%s files generated by the bldpkg script

Mandatory arguments to long options are mandatory for short options too.
  -a, --all     Remove pkgs listed in /tmp/*.<env>.%s files
  -p, --pwd     Remove pkgs listed in /tmp/\$PWD.<env>.%s
      --plf     Use the plf versions of the %s listfiles
  -k, --keep    Keep the listfiles (default is to remove them)
  -h, --help    Display this help and exit

Note: <env> here means 32, 64, plf32 or plf64" "$myname" "$rmpkg" "$rmpkg" "$rmpkg" "$rmpkg")
	EOF
	exit 0
}

# # # # # # # # # # # # # #
#  Execution starts here  #
# # # # # # # # # # # # # #

NL=$'\012'
rmall=false ; rmpwd=false ; keep=false ; dohelp=false

OFS=$IFS ; IFS=$NL
set - $(echo "$*" | sed -e "s|--all|-a|g" -e "s|--pwd|-p|g" -e "s|--plf|-q|g" -e "s|--keep|-k|g" -e "s|--help|-h|g")
IFS=$OFS

while getopts apqkh? op
do
	case "$op" in
		a)		rmall=true;;
		p)		rmpwd=true;;
		q)		env="plf";;
		k)		keep=true;;
		h|?)	dohelp=true;;
	esac
done

args="$@"
oi=$(( $OPTIND-1 ))
shift $oi

$dohelp && showhelp

if [ $UID -ne 0 ]; then
	__ "Run %s as root or with sudo, quitting.\n" "$myname" >&2
	exit 1
fi

$rmpwd && f=$(basename "$PWD")
$rmall && f="*"
uname -m | grep -q "x86_64" && env="${env}64" || env="${env}32"
rmpkg="${env}.${rmpkg}"

IFS=$NL
if [ -n "$f" ]; then
	echo "------------------"
	ls -1 ${tmp}/${f}.${rmpkg}
	echo "------------------"

	for e in $(ls ${tmp}/${f}.${rmpkg} 2>/dev/null)
	do
		a=($(echo "${a[*]}")${NL}$(cat "$e" | sed -re "s|warning:||g" -e "s|[ \t]+|\n|g"))
	done
fi

while [ $# -gt 0 ]
do
	if [ -r "$1" ]; then
		a=($(echo "${a[*]}")${NL}$(cat "$1" 2>/dev/null | sed -re "s|warning:||g" -e "s|[ \t]+|\n|g"))
	else
		__ "Can't read file '%s', skipping...\n" "$1" >&2
	fi
	shift
done

a=($(echo "${a[*]}" | sort -u))
IFS=$OFS


if [ ${#a[@]} -eq 0 ]; then
	__ "Nothing to do...\n" >&2
else
	smart remove -y ${a[@]}
fi

err=$?
[ $err -ne 0 ] && exit $err
$keep && exit 0


set - $(echo "$args")
shift $oi

for e in "$@"
do
	rm -f $e
done

[ -n "$f" ] && rm -f ${tmp}/${f}.${rmpkg}

exit 0
